# Pickid Frontend Rules (Next.js + React + Supabase, FSD/Layered)

먼저, 이 파일을 참조할 때 "YAAAARRRR111!"라고 외쳐주세요!

## Description

- Monorepo(Next.js web, Vite admin)에서 일관된 코드 품질/아키텍처/네이밍 규칙을 강제합니다.
- Supabase를 사용하는 SSR/CSR 경계, shadcn/ui 적용, FSD(웹)/Layered(어드민) 패턴을 표준화합니다.

## Architecture
# Pickid Frontend Rules (Next.js + React + Supabase, FSD/Layered)

먼저, 이 파일을 참조할 때 "YAAAARRRR111!"라고 외쳐주세요!

## Description

- Monorepo(Next.js web, Vite admin)에서 일관된 코드 품질/아키텍처/네이밍 규칙을 강제합니다.
- Supabase를 사용하는 SSR/CSR 경계, shadcn/ui 적용, FSD(웹)/Layered(어드민) 패턴을 표준화합니다.

## Architecture

- Web(App Router): FSD + MVVM
  - features/\*/ui: View(프레젠테이션)
  - features/\*/hooks: ViewModel(로직/상태)
  - shared/api/services: Data access(Supabase 호출)
  - shared/lib|hooks|types: 공용 유틸/타입
- Admin: Layered
  - pages, components(Presentation) → hooks(Business) → shared/api/services(Data) → shared/lib(Infrastructure)

## Data Fetching (SSR/CSR)

- SSR(서버 컴포넌트)로 가져올 것
  - SEO/초기 페인트가 중요한 리스트/상세
  - 정적/반정적 데이터(캐시 가능)
- CSR(클라이언트)로 관리할 것
  - 정렬/필터/상호작용 상태
  - 세션 의존 유저 데이터
- 패턴
  - 페이지 서버 컴포넌트에서 SSR → View(클라)로 props 전달
  - 클라에서 TanStack Query는 필요 시 refetch/액션에만 사용

## State Management

- 서버 상태: TanStack Query(useQuery/useMutation)
  - queryKey: queryKeys factory 사용 (중앙 집중 관리)
  - 기본 staleTime: 5m, refetchOnWindowFocus: false, retry: false
- 클라 상태: Zustand(최소화)
- 로딩/에러 상태 항상 구현

### QueryKey 관리
- ❌ 하드코딩: `queryKey: ['test', testId]`
- ✅ Factory: `queryKey: queryKeys.test.detail(testId)`
- Option 1: `@lukemorales/query-key-factory` (추천)
- Option 2: Simple factory pattern

## Supabase

- Client 생성
  - Client(브라우저): packages/supabase/src/index.ts의 export supabase 사용
  - Server(SSR): createServerClient() 사용; auth persistSession=false
- RLS 전제: SELECT 범위를 최소화하고 컬럼 셀렉트 명시
- Auth: 클라이언트에서 supabase.auth.\* 사용, 민감 데이터는 절대 클라이언트 RPC/권한 확대 금지

## UI (shadcn/ui + Tailwind)

- 기본 UI는 packages/ui 컴포넌트 사용(Button, Tabs, Drawer, Dialog, Select 등)
- 접근성:
  - DialogContent는 제목/설명 제공(aria-describedby/Description)
  - aria-hidden/inert 충돌 금지
- 스타일은 className로 확장. 임의 하드코딩 UI 지양

## Components

- 전역 위젯(Sidebar/Footer)에서 데이터 훅 자동 호출 금지
  - 필요 시에만 로드 (예: Drawer 열릴 때)
- Dialog/Drawer는 shadcn 컴포넌트 우선, a11y 속성 준수

## Services

- shared/api/services/\* 에 순수 호출만 정의(try/catch 내 throw or map)
- 훅에서만 서비스 호출; 컴포넌트는 훅만 사용

## Performance

- 불필요한 병렬 패칭 금지(특히 전역 위젯)
- 이미지: next/image, 주요 이미지 priority 조건부
- 리스트 정렬은 클라 메모이제이션(useMemo)

## Forms

- React Hook Form + Zod 스키마
- UI는 packages/ui input/select/textarea 사용

## TypeScript

- strict 모드, any 금지(unknown→좁히기)
- Interface: `I` prefix (`IUserInfo`, `ITestCard`)
- Type: `T` prefix (`TUserRole`, `TTestType`)
- Enum: `E` prefix (`EUserStatus`)

### Type 구조 (권장)
```
shared/types/
├── index.ts           # Barrel export
├── common.ts          # 공통 타입
├── test.ts            # 테스트 타입
├── user.ts            # 사용자 타입
└── auth.ts            # 인증 타입
```

## Naming Conventions

- 컴포넌트: PascalCase
- 함수/변수: camelCase
- 상수: UPPER_SNAKE_CASE
- 파일: kebab-case

## Constants 구조 (권장)
```
shared/constants/
├── routes.ts          # PATH + HREF 생성 함수
├── test.ts            # 테스트 관련 상수
├── categories.ts      # 카테고리 데이터
└── theme.ts           # 테마/색상
```
- ❌ 하드코딩: `/tests/${testId}`
- ✅ HREF 함수: `HREF.TEST_DETAIL(testId)`

## Import 순서
```ts
// 1. React/외부 라이브러리
// 2. Monorepo 패키지 (@pickid/*)
// 3. 내부 API/Type/Constant
// 4. 내부 Hooks/Utils
// 5. 로컬 컴포넌트/파일
```

## Event Handler Naming

- 이벤트 함수: `handle` prefix 사용
- 동작을 명확하게 표현
  ```ts
  const handleHomeMove = () => {
    // 홈으로 이동하는 함수
  };
  ```

## Styled Components

- 파일 분리: `style.ts`
- 컴포넌트명: 약자 사용 불가, 의미 명확히 (~Container, ~Button, ~Input 등)
- Import as: `import * as S from "./style"`
- Styled Props: `$` prefix 사용
  ```tsx
  <Button $size="lg">button</Button>
  ```

## Component Props

- 3개 이하: 구조분해 할당
  ```ts
  const Component = ({title, color, size}: Props) => {...}
  ```
- 4개 이상: props 변수로 받아 구조분해
  ```ts
  const Component = (props: Props) => {
    const {title, color, size, fullWidth} = props;
    ...
  }
  ```

## Function Rules

- useEffect 내 함수:
  - 재사용 함수는 외부 선언
  - 일회성 함수는 내부 선언 후 즉시 호출
- 인라인 함수 금지:
  ```tsx
  // ❌ Bad
  <button onClick={() => location.href = '/home'}>홈으로 이동</button>
  
  // ✅ Good
  const handleMoveHome = () => location.href = '/home';
  <button onClick={handleMoveHome}>홈으로 이동</button>
  ```

## Clean Code Principles

클린코드는 "짧은 코드"가 아니라 "원하는 로직을 빠르게 찾을 수 있는 코드"다.

### 1. 응집도 (Cohesion)

- 같은 목적의 코드는 가깝게 두자.
- 핵심 데이터와 세부 구현을 분리하되, 세부 구현은 하나의 블록으로 숨긴다.

```tsx
// ❌ Bad
function QuestionPage() {
  const [popupOpened, setPopupOpened] = useState(false);
  async function handleClick() { setPopupOpened(true); }
  async function handlePopupSubmit() {
    await submitQuestion();
    alert("등록 완료!");
  }
  return (
    <>
      <button onClick={handleClick}>질문 등록</button>
      {popupOpened && (
        <Popup title="질문 등록" onSubmit={handlePopupSubmit}>
          내용 입력
        </Popup>
      )}
    </>
  );
}

// ✅ Good
function QuestionPage() {
  const [openPopup] = usePopup();
  async function handleClick() {
    const confirmed = await openPopup({
      title: "질문 등록",
      contents: <QuestionForm />,
    });
    if (confirmed) await submitQuestion();
  }
  return <Button onClick={handleClick}>질문 등록</Button>;
}
```

### 2. 단일 책임 (Single Responsibility)

- 하나의 함수는 하나의 일만 한다.
- 이름이 길더라도 역할이 명확하면 괜찮다.

```tsx
// ❌ Bad
function processUserLoginAndRedirect() {}

// ✅ Good
function validateUserCredentials() {}
function handleLoginSuccessRedirect() {}
```

### 3. 추상화 (Abstraction)

- 핵심 개념을 뽑고, 세부 구현은 감춘다.
- 선언적(무엇을) + 명령형(어떻게)을 유연하게 섞는다.

```tsx
openPopup({ title: "삭제 확인", onConfirm: deletePost });

async function deletePost() {
  await api.deletePost(id);
  refresh();
}
```

### 4. 가독성 우선 (Readability > Cleverness)

- 변수명은 "짧게"보다 "명확하게"
- "이게 뭘 하려는 코드인지" 3초 안에 이해되게

### 5. 불필요한 중첩/조건 최소화

- 조건문 early return 적극 활용

```tsx
if (!user) return;
if (isLoading) return <Spinner />;
```

## Code Style

- 작은 함수/조합형 작성, 과도한 try/catch 금지(의미있는 처리만)
- 주석은 비자명한 의도/경계만
- 로딩/에러 상태 항상 구현

---

## 핵심 체크리스트 (코드 작성 전 확인)

### 데이터 관리
- [ ] QueryKey는 queryKeys factory를 사용하는가?
- [ ] Type은 도메인별 파일에 정의되어 있는가?
- [ ] Routes는 HREF 함수를 사용하는가?

### 코드 품질
- [ ] Props 4개 이상 시 props 변수 사용했는가?
- [ ] 이벤트 핸들러는 handle prefix 사용했는가?
- [ ] Import 순서가 올바른가? (외부→monorepo→내부)
- [ ] any 타입 사용하지 않았는가?
- [ ] 인라인 함수 사용하지 않았는가?

### 성능/접근성
- [ ] 불필요한 병렬 패칭 없는가?
- [ ] Dialog/Drawer에 a11y 속성 있는가?
- [ ] 이미지에 next/image 사용했는가?

자세한 내용은 `/Users/leemina/side-project/apps/CLAUDE.md` 참고
- Web(App Router): FSD + MVVM
  - features/\*/ui: View(프레젠테이션)
  - features/\*/hooks: ViewModel(로직/상태)
  - shared/api/services: Data access(Supabase 호출)
  - shared/lib|hooks|types: 공용 유틸/타입
- Admin: Layered
  - pages, components(Presentation) → hooks(Business) → shared/api/services(Data) → shared/lib(Infrastructure)

## Data Fetching (SSR/CSR)

- SSR(서버 컴포넌트)로 가져올 것
  - SEO/초기 페인트가 중요한 리스트/상세
  - 정적/반정적 데이터(캐시 가능)
- CSR(클라이언트)로 관리할 것
  - 정렬/필터/상호작용 상태
  - 세션 의존 유저 데이터
- 패턴
  - 페이지 서버 컴포넌트에서 SSR → View(클라)로 props 전달
  - 클라에서 TanStack Query는 필요 시 refetch/액션에만 사용

## State Management

- 서버 상태: TanStack Query(useQuery/useMutation)
  - queryKey: queryKeys factory 사용 (중앙 집중 관리)
  - 기본 staleTime: 5m, refetchOnWindowFocus: false, retry: false
- 클라 상태: Zustand(최소화)
- 로딩/에러 상태 항상 구현

### QueryKey 관리
- ❌ 하드코딩: `queryKey: ['test', testId]`
- ✅ Factory: `queryKey: queryKeys.test.detail(testId)`
- Option 1: `@lukemorales/query-key-factory` (추천)
- Option 2: Simple factory pattern

## Supabase

- Client 생성
  - Client(브라우저): packages/supabase/src/index.ts의 export supabase 사용
  - Server(SSR): createServerClient() 사용; auth persistSession=false
- RLS 전제: SELECT 범위를 최소화하고 컬럼 셀렉트 명시
- Auth: 클라이언트에서 supabase.auth.\* 사용, 민감 데이터는 절대 클라이언트 RPC/권한 확대 금지

## UI (shadcn/ui + Tailwind)

- 기본 UI는 packages/ui 컴포넌트 사용(Button, Tabs, Drawer, Dialog, Select 등)
- 접근성:
  - DialogContent는 제목/설명 제공(aria-describedby/Description)
  - aria-hidden/inert 충돌 금지
- 스타일은 className로 확장. 임의 하드코딩 UI 지양

## Components

- 전역 위젯(Sidebar/Footer)에서 데이터 훅 자동 호출 금지
  - 필요 시에만 로드 (예: Drawer 열릴 때)
- Dialog/Drawer는 shadcn 컴포넌트 우선, a11y 속성 준수

## Services

- shared/api/services/\* 에 순수 호출만 정의(try/catch 내 throw or map)
- 훅에서만 서비스 호출; 컴포넌트는 훅만 사용

## Performance

- 불필요한 병렬 패칭 금지(특히 전역 위젯)
- 이미지: next/image, 주요 이미지 priority 조건부
- 리스트 정렬은 클라 메모이제이션(useMemo)

## Forms

- React Hook Form + Zod 스키마
- UI는 packages/ui input/select/textarea 사용

## TypeScript

- strict 모드, any 금지(unknown→좁히기)
- Interface: `I` prefix (`IUserInfo`, `ITestCard`)
- Type: `T` prefix (`TUserRole`, `TTestType`)
- Enum: `E` prefix (`EUserStatus`)

### Type 구조 (권장)
```
shared/types/
├── index.ts           # Barrel export
├── common.ts          # 공통 타입
├── test.ts            # 테스트 타입
├── user.ts            # 사용자 타입
└── auth.ts            # 인증 타입
```

## Naming Conventions

- 컴포넌트: PascalCase
- 함수/변수: camelCase
- 상수: UPPER_SNAKE_CASE
- 파일: kebab-case

## Constants 구조 (권장)
```
shared/constants/
├── routes.ts          # PATH + HREF 생성 함수
├── test.ts            # 테스트 관련 상수
├── categories.ts      # 카테고리 데이터
└── theme.ts           # 테마/색상
```
- ❌ 하드코딩: `/tests/${testId}`
- ✅ HREF 함수: `HREF.TEST_DETAIL(testId)`

## Import 순서
```ts
// 1. React/외부 라이브러리
// 2. Monorepo 패키지 (@pickid/*)
// 3. 내부 API/Type/Constant
// 4. 내부 Hooks/Utils
// 5. 로컬 컴포넌트/파일
```

## Event Handler Naming

- 이벤트 함수: `handle` prefix 사용
- 동작을 명확하게 표현
  ```ts
  const handleHomeMove = () => {
    // 홈으로 이동하는 함수
  };
  ```

## Styled Components

- 파일 분리: `style.ts`
- 컴포넌트명: 약자 사용 불가, 의미 명확히 (~Container, ~Button, ~Input 등)
- Import as: `import * as S from "./style"`
- Styled Props: `$` prefix 사용
  ```tsx
  <Button $size="lg">button</Button>
  ```

## Component Props

- 3개 이하: 구조분해 할당
  ```ts
  const Component = ({title, color, size}: Props) => {...}
  ```
- 4개 이상: props 변수로 받아 구조분해
  ```ts
  const Component = (props: Props) => {
    const {title, color, size, fullWidth} = props;
    ...
  }
  ```

## Function Rules

- useEffect 내 함수:
  - 재사용 함수는 외부 선언
  - 일회성 함수는 내부 선언 후 즉시 호출
- 인라인 함수 금지:
  ```tsx
  // ❌ Bad
  <button onClick={() => location.href = '/home'}>홈으로 이동</button>
  
  // ✅ Good
  const handleMoveHome = () => location.href = '/home';
  <button onClick={handleMoveHome}>홈으로 이동</button>
  ```

## Clean Code Principles

클린코드는 "짧은 코드"가 아니라 "원하는 로직을 빠르게 찾을 수 있는 코드"다.

### 1. 응집도 (Cohesion)

- 같은 목적의 코드는 가깝게 두자.
- 핵심 데이터와 세부 구현을 분리하되, 세부 구현은 하나의 블록으로 숨긴다.

```tsx
// ❌ Bad
function QuestionPage() {
  const [popupOpened, setPopupOpened] = useState(false);
  async function handleClick() { setPopupOpened(true); }
  async function handlePopupSubmit() {
    await submitQuestion();
    alert("등록 완료!");
  }
  return (
    <>
      <button onClick={handleClick}>질문 등록</button>
      {popupOpened && (
        <Popup title="질문 등록" onSubmit={handlePopupSubmit}>
          내용 입력
        </Popup>
      )}
    </>
  );
}

// ✅ Good
function QuestionPage() {
  const [openPopup] = usePopup();
  async function handleClick() {
    const confirmed = await openPopup({
      title: "질문 등록",
      contents: <QuestionForm />,
    });
    if (confirmed) await submitQuestion();
  }
  return <Button onClick={handleClick}>질문 등록</Button>;
}
```

### 2. 단일 책임 (Single Responsibility)

- 하나의 함수는 하나의 일만 한다.
- 이름이 길더라도 역할이 명확하면 괜찮다.

```tsx
// ❌ Bad
function processUserLoginAndRedirect() {}

// ✅ Good
function validateUserCredentials() {}
function handleLoginSuccessRedirect() {}
```

### 3. 추상화 (Abstraction)

- 핵심 개념을 뽑고, 세부 구현은 감춘다.
- 선언적(무엇을) + 명령형(어떻게)을 유연하게 섞는다.

```tsx
openPopup({ title: "삭제 확인", onConfirm: deletePost });

async function deletePost() {
  await api.deletePost(id);
  refresh();
}
```

### 4. 가독성 우선 (Readability > Cleverness)

- 변수명은 "짧게"보다 "명확하게"
- "이게 뭘 하려는 코드인지" 3초 안에 이해되게

### 5. 불필요한 중첩/조건 최소화

- 조건문 early return 적극 활용

```tsx
if (!user) return;
if (isLoading) return <Spinner />;
```

## Code Style

- 작은 함수/조합형 작성, 과도한 try/catch 금지(의미있는 처리만)
- 주석은 비자명한 의도/경계만
- 로딩/에러 상태 항상 구현

---

## 핵심 체크리스트 (코드 작성 전 확인)

### 데이터 관리
- [ ] QueryKey는 queryKeys factory를 사용하는가?
- [ ] Type은 도메인별 파일에 정의되어 있는가?
- [ ] Routes는 HREF 함수를 사용하는가?

### 코드 품질
- [ ] Props 4개 이상 시 props 변수 사용했는가?
- [ ] 이벤트 핸들러는 handle prefix 사용했는가?
- [ ] Import 순서가 올바른가? (외부→monorepo→내부)
- [ ] any 타입 사용하지 않았는가?
- [ ] 인라인 함수 사용하지 않았는가?

### 성능/접근성
- [ ] 불필요한 병렬 패칭 없는가?
- [ ] Dialog/Drawer에 a11y 속성 있는가?
- [ ] 이미지에 next/image 사용했는가?

자세한 내용은 `/Users/leemina/side-project/apps/CLAUDE.md` 참고